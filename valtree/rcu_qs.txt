Quiescent States for RCU are:
  - Context Switch
  - Idle (Idle loop or Full Dynticks Idle)
  - Userland

  So, whenever we are at one of these states, a QS should
be reported to RCU. This is done by invoking rcu_sched_qs()
function. But when is this function called?
  This function is called from:
1) The __schedule() function (main scheduler function)
2) __do_softirq() function. This function, except from
   processing the pending SOFTIRQs, also reports a QS to RCU.
   This function is called, among other times, at irq_exit()
   function (when returning from interrupt context).
3) rcu_check_callbacks() function. This function is called
   from the update_process_times() function, which is called
   from the timer interrupt handler. rcu_check_callbacks()
   reports a QS to RCU (by calling rcu_sched_qs()), and also
   raises a SOFTIRQ (raise_softirq(RCU_SOFTIRQ)).

-----------------------------------
When are SOFTIRQs executed?
Checks for active (pending) softirqs should be perfomed periodically,
but without inducing too much overhead. They are performed in a few
points of the kernel code. Here is a list of the most significant
points (be warned that number and position of the softirq checkpoints
change both with the kernel version and with the supported hardware
architecture):

-When the kernel invokes the local_bh_enable( ) function[*] to enable
softirqs on the local CPU

-When the do_IRQ( ) function finishes handling an I/O interrupt and
invokes the irq_exit( ) macro

-If the system uses an I/O APIC, when the smp_apic_timer_interrupt( )
function finishes handling a local timer interrupt (see the section
"Timekeeping Architecture in Multiprocessor Systems" in Chapter 6)

-In multiprocessor systems, when a CPU finishes handling a function
triggered by a CALL_FUNCTION_VECTOR interprocessor interrupt

-When one of the special ksoftirqd/n kernel threads is awakened
(see later)

-----------------------------------
Τα callbacks του RCU εξυπηρετούνται όταν εξυπηρετηθεί το αντίστοιχο
softirq. Είναι σημαντικό να διακρίνουμε ότι είναι διαφορετικό
πράγμα τα σημεία που γίνεται noted ότι το RCU είναι σε QS (δηλαδή
context switch, __do_softirq() και rcu_check_callbacks()), διαφορετικό
το πότε γίνεται raise ένα softirq (για το rcu το κάνει η check_callbacks,
αλλά γενικά γίνεται όποτε θέλουμε),
και διαφορετικό το πότε εξυπηρετείται ένα SOFTIRQ (δες προηγούμενη
ενότητα).
-----------------------------------
Τέλος, σημειώνεται ότι η rcu_sched_qs() δεν σημειώνει στο αντίστοιχο
node ότι ο επεξεργαστής πέρασε σε qs. Αυτό σημαίνει ότι η συνάρτηση
αυτή δεν πρόκειται να προκαλέσει το τέλος μιας grace period. Η
συνάρτηση η οποία όντως προχωράει την grace period είναι η
rcu_process_callbacks. Αν ο kernel είναι tickless (οπότε και δεν
θα τρέξει ποτέ η process_callbacks -αφού τα INTs είναι απενεργοποιημένα-
και άρα δεν θα γίνει advance η grace period, εκτός από την
rcu_sched_qs, στο context switch τρέχει και η rcu_momentary_dyntick_idle,
της οποίας οι ενέργειες θα αξιοποιηθούν από την force_quiescent_state.
Για να γίνει όμως όντως context_switch (αφού αν τρέξει η cond_resched
δεν θα γίνει καν), η fqs θετει την rcu_sched_qs_mask μεταβλητή για
τον αντίστοιχο επεξεργαστή (η οποία μεταβάλει τη συμπεριφορά της
rcu_Note_context_switch που τρέχει στην __schedule) και ΑΝΑΓΚΑΖΕΙ
τον scheduler να τρέξει στον επεξεργαστή αυτόν.
